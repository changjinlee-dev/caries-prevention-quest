<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Caries Prevention Quest</title>
  <meta name="description" content="A kid-friendly web game teaching prevention for high-caries-risk children: candy cracks, OHI, floss, sealants, and regular visits." />
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-sky-50">
  <div id="root"></div>

  <!-- React + Babel -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    /* ---------- Tooth SVGs (primary dentition silhouettes) ---------- */
    const PRIMARY_ARCH = [
      "secondMolar","firstMolar","canine","lateralIncisor","centralIncisor",
      "centralIncisor","lateralIncisor","canine","firstMolar","secondMolar"
    ];

    function pathForTooth(type){
      // Simple, kid-friendly silhouettes (viewBox 0 0 100 120)
      switch(type){
        case "centralIncisor":
          return "M50 6 C36 6,22 20,22 38 C22 60,36 64,38 78 C42 96,48 112,50 112 C52 112,58 96,62 78 C64 64,78 60,78 38 C78 20,64 6,50 6 Z";
        case "lateralIncisor":
          return "M50 8 C38 8,26 22,26 40 C26 58,36 62,38 76 C41 92,47 110,50 110 C53 110,59 92,62 76 C64 62,74 58,74 40 C74 22,62 8,50 8 Z";
        case "canine":
          return "M50 4 C42 10,30 26,28 42 C26 58,36 68,38 82 C42 100,48 112,50 112 C52 112,58 100,62 82 C64 68,74 58,72 42 C70 26,58 10,50 4 Z";
        case "firstMolar":
          return "M30 18 C22 18,18 30,18 42 C18 58,30 70,36 82 C40 92,44 108,50 108 C56 108,60 92,64 82 C70 70,82 58,82 42 C82 30,78 18,70 18 C60 12,40 12,30 18 Z";
        case "secondMolar":
        default:
          return "M26 20 C18 20,14 32,14 44 C14 62,28 72,34 86 C38 98,44 110,50 110 C56 110,62 98,66 86 C72 72,86 62,86 44 C86 32,82 20,74 20 C62 12,38 12,26 20 Z";
      }
    }

    const Tooth = ({ clean = false, size="w-10 h-12", type="firstMolar", label }) => {
      const fill = clean ? "#ffffff" : "#fde68a";        // yellow when dirty
      const stroke = clean ? "#cbd5e1" : "#f59e0b";
      const d = pathForTooth(type);
      return (
        <svg
          viewBox="0 0 100 120"
          className={`${size} m-0.5 drop-shadow-sm`}
          role="img"
          aria-label={label || `${type} ${clean ? "clean" : "needs cleaning"}`}
        >
          <defs>
            <radialGradient id="shine" cx="45%" cy="28%" r="60%">
              <stop offset="0%" stopColor="#ffffff"/>
              <stop offset="70%" stopColor={clean ? "#f3f6fb" : "#fef3c7"}/>
              <stop offset="100%" stopColor={clean ? "#e5edf7" : "#fde68a"}/>
            </radialGradient>
          </defs>
          <path d={d} fill={clean ? "url(#shine)" : fill} stroke={stroke} strokeWidth="2"/>
          {/* Simple detail lines by type */}
          {type.includes("Molar") && (
            <path d="M28 48 C42 38,58 58,72 48 M50 30 C52 46,52 62,50 76"
                  stroke={clean ? "#94a3b8" : "#b45309"} strokeWidth="2" fill="none" opacity="0.45" />
          )}
          {type.includes("Incisor") && (
            <path d="M30 44 C40 38,60 38,70 44" stroke={clean ? "#94a3b8" : "#b45309"} strokeWidth="2" fill="none" opacity="0.35" />
          )}
          {type === "canine" && (
            <path d="M35 46 C50 36,65 46,65 46" stroke={clean ? "#94a3b8" : "#b45309"} strokeWidth="2" fill="none" opacity="0.35" />
          )}
        </svg>
      );
    };

    /* ---------- Shared UI ---------- */
    const Progress = ({ value }) => (
      <div className="w-full bg-gray-200 rounded-full h-3">
        <div className="h-3 rounded-full transition-all bg-blue-500" style={{ width: `${Math.min(100, Math.max(0, value))}%` }} />
      </div>
    );

    const Card = ({ title, children, footer }) => (
      <div className="bg-white rounded-2xl shadow-lg p-5 border border-gray-100 w-full max-w-4xl">
        <h2 className="text-xl font-semibold mb-3">{title}</h2>
        <div>{children}</div>
        {footer && <div className="mt-4 text-sm text-gray-600">{footer}</div>}
      </div>
    );

    const Button = ({ children, onClick, variant = "default", disabled }) => (
      <button
        onClick={onClick}
        disabled={disabled}
        className={`px-4 py-2 rounded-xl font-medium shadow-sm transition-all mr-2 mb-2 ${
          variant === "default"
            ? "bg-blue-600 text-white hover:bg-blue-700 disabled:bg-blue-300"
            : variant === "ghost"
            ? "bg-white border border-gray-300 hover:bg-gray-50"
            : variant === "success"
            ? "bg-emerald-600 text-white hover:bg-emerald-700 disabled:bg-emerald-300"
            : "bg-slate-800 text-white hover:bg-slate-900"
        }`}
      >
        {children}
      </button>
    );

    function useTimer(active, seconds, onDone) {
      const [time, setTime] = useState(seconds);
      useEffect(() => { if (active) setTime(seconds); }, [seconds, active]);
      useEffect(() => {
        if (!active) return;
        const id = setInterval(() => {
          setTime(t => {
            if (t <= 1) { clearInterval(id); onDone?.(); return 0; }
            return t - 1;
          });
        }, 1000);
        return () => clearInterval(id);
      }, [active, onDone]);
      return time;
    }

    /* ---------- Level 1: Candy Crack ---------- */
    function CandyCrack({ onComplete }) {
      const sceneRef = useRef(null);
      const [hits, setHits] = useState(0);
      const [severity, setSeverity] = useState(0);   // 0..100 (logical)
      const [played, setPlayed] = useState(false);
      const [brushing, setBrushing] = useState(false);
      const [cap, setCap] = useState("Drop a candy onto the tooth.");
      const canNext = played && severity === 0;

      const hitsRef = useRef(0);
      const sevRef  = useRef(0);
      useEffect(() => { hitsRef.current = hits; }, [hits]);
      useEffect(() => { sevRef.current  = severity; }, [severity]);

      const [sevBar, setSevBar] = useState(0);
      const sevBarRef = useRef(0);
      const sevAnimRef = useRef(null);

      useEffect(() => {
        if (sevAnimRef.current) cancelAnimationFrame(sevAnimRef.current);
        const step = () => {
          const target = sevRef.current;
          const curr   = sevBarRef.current;
          const diff   = target - curr;
          if (Math.abs(diff) < 0.2) {
            sevBarRef.current = target;
            setSevBar(target);
            sevAnimRef.current = null;
            return;
          }
          const next = curr + diff * 0.2;
          sevBarRef.current = next;
          setSevBar(next);
          sevAnimRef.current = requestAnimationFrame(step);
        };
        sevAnimRef.current = requestAnimationFrame(step);
        return () => sevAnimRef.current && cancelAnimationFrame(sevAnimRef.current);
      }, [severity]);

      const els = useRef({});
      useEffect(() => {
        const scene = sceneRef.current;
        const toothSVG = scene.querySelector("#toothSVG");
        els.current = {
          scene, toothSVG,
          cracks: scene.querySelector("#cracks"),
          pit: scene.querySelector("#pit"),
          mainCrack: scene.querySelector("#mainCrack"),
          branch1: scene.querySelector("#branch1"),
          branch2: scene.querySelector("#branch2"),
          branch3: scene.querySelector("#branch3"),
          plaque: scene.querySelector("#plaque"),
          brush: scene.querySelector("#brush"),
          foam: scene.querySelector("#foam"),
        };
        applyCrackVisuals(0, 0);
      }, []);

      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

      function flashImpact(pxX, pxY) {
        const { toothSVG } = els.current;
        if (!toothSVG) return;
        const pt = toothSVG.createSVGPoint();
        pt.x = pxX; pt.y = pxY;
        const p = pt.matrixTransform(toothSVG.getScreenCTM().inverse());
        const circ = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circ.setAttribute("cx", p.x);
        circ.setAttribute("cy", 110);
        circ.setAttribute("r", 3);
        circ.setAttribute("fill", "#fff");
        circ.setAttribute("opacity", "0.9");
        toothSVG.appendChild(circ);
        circ.animate([{opacity:0.9,r:3},{opacity:0.0,r:22}],{duration:280,easing:'ease-out'}).onfinish=()=>circ.remove();
      }

      function applyCrackVisuals(nextSeverity, nextHits) {
        const { cracks, pit, mainCrack, branch1, branch2, branch3 } = els.current;
        if (!cracks || !pit) return;
        const s = clamp(nextSeverity, 0, 100);

        if (s <= 0 && nextHits === 0) {
          cracks.style.opacity = "0";
          pit.setAttribute("opacity","0.0");
          pit.setAttribute("r","0.1");
          [branch1, branch2, branch3].forEach(p=>p && (p.style.opacity="0"));
          [mainCrack, branch1, branch2, branch3].forEach(p=>p && (p.style.strokeWidth="1.4"));
          cracks.style.stroke = "#4b3b34";
          return;
        }

        cracks.style.opacity = s > 0 ? "1" : "0.0001";
        const sw = 1.4 + (s/100)*3.8;
        [mainCrack, branch1, branch2, branch3].forEach(p=>p && (p.style.strokeWidth = sw.toFixed(2)));

        const r = Math.round(0x4b + (0x1a-0x4b)*(s/100));
        const g = Math.round(0x3b + (0x14-0x3b)*(s/100));
        const b = Math.round(0x34 + (0x12-0x34)*(s/100));
        cracks.style.stroke = `rgb(${r},${g},${b})`;

        branch1.style.opacity = s > 20 ? "1" : "0";
        branch2.style.opacity = s > 45 ? "1" : "0";
        branch3.style.opacity = s > 70 ? "1" : "0";

        const pitR = 0.5 + (s/100)*10;
        pit.setAttribute("r", pitR.toFixed(2));
        pit.setAttribute("opacity", s > 0 ? Math.min(0.85, 0.2 + (s/100)).toFixed(2) : "0.0");
      }

      function applyImpact(deltaSev = 9) {
        const nh = hitsRef.current + 1;
        const ns = clamp(sevRef.current + deltaSev, 0, 100);
        setHits(nh);
        setSeverity(ns);
        setPlayed(true);
        hitsRef.current = nh;
        sevRef.current  = ns;

        const { plaque } = els.current;
        if (plaque) plaque.style.opacity = String(Math.min(0.45, 0.10 + nh * 0.03));
        applyCrackVisuals(ns, nh);
      }

      function impactAt(pxX, pxY) {
        setCap("Ouch! The crack deepens and darkens.");
        applyImpact(9);
        flashImpact(pxX, pxY);
      }

      function dropCandy() {
        const { scene } = els.current;
        if (!scene) return;
        const rect = scene.getBoundingClientRect();
        const minX = rect.width*0.23, maxX = rect.width*0.77;
        const left = minX + Math.random()*(maxX-minX);

        const c = document.createElement("div");
        c.className = "absolute w-7 h-7 rounded-full";
        c.style.background = "repeating-linear-gradient(45deg,#ff7aa2 0 7px,#ffd4e3 7px 14px)";
        c.style.boxShadow = "inset 0 0 6px rgba(0,0,0,.3)";
        c.style.left = left + "px";
        c.style.top  = "-18px";
        c.style.borderRadius = "50%";
        c.style.transform = "translate(-50%,-50%) rotate(0deg)";
        scene.appendChild(c);

        let y = -18, vy = 1 + Math.random()*0.7, rot = 0;
        const g = 0.28, targetY = rect.height*0.28;

        const tick = () => {
          vy += g; y += vy; rot += 6 + Math.random()*2;
          c.style.transform = `translate(-50%,-50%) translateY(${y}px) rotate(${rot}deg)`;
          if (y >= targetY) {
            c.style.transition = "opacity .16s ease"; c.style.opacity = "0";
            impactAt(left, targetY);
            setTimeout(()=>c.remove(), 180);
            return;
          }
          requestAnimationFrame(tick);
        };
        requestAnimationFrame(tick);
      }

      function resetAll() {
        setHits(0); setSeverity(0); hitsRef.current=0; sevRef.current=0;
        setPlayed(false); setBrushing(false);
        setCap("Reset. Drop a candy onto the tooth.");
        const { cracks, pit, plaque, mainCrack, branch1, branch2, branch3, brush } = els.current;
        if (cracks) cracks.style.opacity = "0";
        if (pit) { pit.setAttribute("r","0.1"); pit.setAttribute("opacity","0.0"); }
        if (plaque) plaque.style.opacity = "0.10";
        [mainCrack,branch1,branch2,branch3].forEach(p=>p && (p.style.strokeWidth="1.4"));
        if (brush) { brush.style.opacity = "0"; brush.style.transform = "translateX(0) rotate(0deg)"; }
      }

      function runBrush() {
        const { scene, brush, foam, plaque } = els.current;
        if (!scene || !brush) return;

        if (!played && sevRef.current === 0) {
          setCap("Oops! Scrubbing without candy still irritated a spot.");
          applyImpact(10);
        }

        if (sevRef.current === 0) { setCap("Already clean ‚Äî great job!"); return; }
        if (brushing) return;
        setBrushing(true);

        const rect = scene.getBoundingClientRect();
        brush.style.opacity = "1";
        brush.style.transition = "none";
        brush.style.left = `${rect.width/2 - 80}px`;
        brush.style.top  = `${rect.height*0.22}px`;

        let offset = 0, dir = 1, passes = 0;
        const maxSwing = 34, speed = 3.4;

        const scrub = () => {
          if (sevRef.current <= 0) { finishBrushing(true); return; }

          offset += dir * speed;
          if (offset > maxSwing || offset < -maxSwing) { dir *= -1; passes++; }
          const tilt = (offset / maxSwing) * 6;
          brush.style.transform = `translateX(${offset}px) rotate(${tilt}deg)`;
          if (foam) foam.style.opacity = (0.25 + 0.5*Math.abs(Math.sin(offset*0.12))).toFixed(2);

          const ns = Math.max(0, sevRef.current - 0.28);
          setSeverity(ns); sevRef.current = ns;
          applyCrackVisuals(ns, hitsRef.current);

          if (plaque) {
            plaque.style.opacity = String(
              Math.max(0.05, parseFloat(plaque.style.opacity || "0.10") - 0.004)
            );
          }

          if (passes < 60 && sevRef.current > 0) requestAnimationFrame(scrub);
          else finishBrushing(sevRef.current === 0);
        };

        function finishBrushing(clean) {
          brush.style.opacity = "0";
          brush.style.transform = "translateX(0) rotate(0deg)";
          setBrushing(false);
          setCap(clean ? "Tooth is clean ‚Äî severity 0." : "Cleaner! Keep brushing to reach 0.");
        }

        requestAnimationFrame(scrub);
      }

      const hitPct = Math.min(100, hits * 8);
      const severityPct = Math.min(100, Math.max(0, sevBar));

      return (
        <Card
          title="Level 1 ‚Äì Candy Crack (Cause & Clean)"
          footer={<div>
            <p className="mb-1">Goal: Drop candy to make cracks, then brush side‚Äëto‚Äëside to reduce severity back to <b>0</b>.</p>
            <p>Unlock <b>Next Level</b> after you‚Äôve dropped candy at least once and fully cleaned the tooth.</p>
          </div>}
        >
          <div className="flex flex-wrap items-center gap-2 mb-4">
            <Button onClick={dropCandy}>üç¨ Drop Candy</Button>
            <Button variant="ghost" onClick={runBrush}>ü™• Toothbrush</Button>
            <Button variant="ghost" onClick={resetAll}>Reset</Button>
            <Button variant="success" disabled={!canNext} onClick={() => onComplete?.()}>Next Level ‚ñ∂</Button>
            <span className="text-sm text-gray-600">{cap}</span>
          </div>

          <div className="grid grid-cols-2 gap-4 mb-3">
            <div>
              <div className="flex items-center justify-between text-xs text-gray-600 mb-1">
                <span>Candy hits</span><span className="font-semibold">{hits}</span>
              </div>
              <div className="w-full bg-gray-200 rounded-full h-3">
                <div className="h-3 rounded-full bg-cyan-500 transition-all" style={{width:`${hitPct}%`}} />
              </div>
            </div>
            <div>
              <div className="flex items-center justify-between text-xs text-gray-600 mb-1">
                <span>Crack severity</span><span className="font-semibold">{Math.round(severity)}</span>
              </div>
              <div className="w-full bg-gray-200 rounded-full h-3">
                <div className="h-3 rounded-full bg-rose-500" style={{width:`${severityPct.toFixed(1)}%`}} />
              </div>
            </div>
          </div>

          <div ref={sceneRef} className="relative h-[420px] rounded-2xl overflow-hidden bg-gradient-to-b from-sky-100 to-sky-200 border border-sky-300">
            <div className="absolute left-3 bottom-3 bg-white/80 text-slate-800 text-sm px-3 py-2 rounded-xl border border-white">
              {cap}
            </div>

            <svg id="toothSVG" viewBox="0 0 400 360" className="w-full h-full">
              <defs>
                <radialGradient id="enamelGrad" cx="50%" cy="35%" r="65%">
                  <stop offset="0%" stopColor="#ffffff"/><stop offset="70%" stopColor="#f3f6fb"/><stop offset="100%" stopColor="#e6ebf2"/>
                </radialGradient>
                <filter id="soft" x="-40%" y="-40%" width="180%" height="180%"><feGaussianBlur stdDeviation="6"/></filter>
              </defs>

              <path id="plaque" d="M200 48 C160 30,114 62,118 116 C122 170,152 188,164 226 C176 266,184 308,200 308
                                    C216 308,224 266,236 226 C248 188,278 170,282 116 C286 62,240 30,200 48 Z"
                    fill="#e8d57a" opacity="0.10" filter="url(#soft)"></path>

              <path d="M200 48 C160 30,114 62,118 116 C122 170,152 188,164 226 C176 266,184 308,200 308
                       C216 308,224 266,236 226 C248 188,278 170,282 116 C286 62,240 30,200 48 Z"
                    fill="url(#enamelGrad)" stroke="#d1d9e6" strokeWidth="1.2"></path>

              <g id="cracks" fill="none" stroke="#4b3b34" strokeLinecap="round" strokeLinejoin="round" opacity="0.0">
                <path id="mainCrack" d="M190 115 C 196 126, 202 140, 208 154 C 210 160, 206 170, 212 182"/>
                <path id="branch1" d="M202 138 C 190 146, 182 154, 176 162" opacity="0"/>
                <path id="branch2" d="M206 152 C 220 160, 230 168, 236 176" opacity="0"/>
                <path id="branch3" d="M196 132 C 188 124, 180 120, 172 118" opacity="0"/>
              </g>

              <circle id="pit" cx="206" cy="152" r="0.1" fill="#3b2b25" opacity="0.0"></circle>
            </svg>

            <div id="brush" className="absolute left-[-9999px] top-0 opacity-0 w-40 h-9 rounded-lg bg-blue-500 shadow-md flex items-center pl-4 gap-2 will-change-transform">
              <div className="w-20 h-4 bg-blue-200 rounded"></div>
              <div id="foam" className="absolute left-16 top-1 w-20 h-6 rounded-full bg-white/80 blur-[1px] opacity-0"></div>
            </div>
          </div>
        </Card>
      );
    }

    /* ---------- Level 2: Brush Boss (maxillary flipped + robust hit-testing) ---------- */
    function BrushBoss({ onComplete, onFail }) {
      const cols = 10, rows = 2, total = cols * rows; // 20
      const [grid, setGrid] = useState(() => {
        const arr = Array(total).fill(false);
        let dirty = 10;
        while (dirty > 0) {
          const i = Math.floor(Math.random() * total);
          if (!arr[i]) { arr[i] = true; dirty--; }
        }
        return arr;
      });
      const needed = 10;
      const cleaned = useMemo(() => 10 - grid.filter(Boolean).length, [grid]);
      const [brushing, setBrushing] = useState(false);
      const time = useTimer(true, 30, () => onFail?.());

      const handleBrush = (idx) => {
        setGrid(g => {
          if (!g[idx]) return g;
          const copy = [...g];
          copy[idx] = false;
          return copy;
        });
      };

      // helper for mouse/touch move across nested elements
      const handleFromEvent = (e) => {
        let clientX, clientY;
        if (e.touches && (e.touches[0] || e.changedTouches?.[0])) {
          const t = e.touches[0] || e.changedTouches[0];
          clientX = t.clientX; clientY = t.clientY;
        } else {
          clientX = e.clientX; clientY = e.clientY;
        }
        const el = document.elementFromPoint(clientX, clientY);
        const cell = el?.closest?.("[data-idx]");
        if (!cell) return;
        const idx = Number(cell.dataset.idx);
        if (!Number.isNaN(idx)) handleBrush(idx);
      };

      useEffect(() => { if (cleaned >= needed) onComplete?.(); }, [cleaned, needed, onComplete]);

      return (
        <Card
          title="Level 2 ‚Äì Brush Boss (OHI)"
          footer={<div>
            <p className="mb-1">Tip: Brush all tooth surfaces in small circles for 2 minutes, twice a day.</p>
            <p>Goal: There are <b>20 teeth</b> in <b>2 rows √ó 10</b> and <b>10 yellow</b>. Clean all 10 yellow teeth.</p>
          </div>}
        >
          {/* header row (closed properly) */}
          <div className="flex items-center justify-between mb-3">
            <div className="text-sm">Time: <span className="font-semibold">{time}s</span></div>
            <div className="text-sm">Cleaned: <span className="font-semibold">{cleaned}/10</span></div>
          </div>

          <Progress value={(cleaned / 10) * 100} />

          {/* grid */}
          <div
            className="select-none grid mt-3 gap-1"
            style={{ gridTemplateColumns: `repeat(${cols}, minmax(0, 1fr))` }}
            onMouseDown={() => setBrushing(true)}
            onMouseUp={() => setBrushing(false)}
            onMouseLeave={() => setBrushing(false)}
            onMouseMove={(e) => { if (brushing) handleFromEvent(e); }}
            onTouchStart={() => setBrushing(true)}
            onTouchEnd={() => setBrushing(false)}
            onTouchMove={(e) => handleFromEvent(e)}
          >
            {grid.map((hasPlaque, i) => {
              const col = i % cols;
              const row = Math.floor(i / cols);      // 0 = TOP (maxillary), 1 = BOTTOM (mandibular)
              const type = PRIMARY_ARCH[col];
              const flipped = row === 0;              // flip the top row only
              return (
                <div
                  key={i}
                  data-idx={i}
                  className="flex items-center justify-center"
                  aria-label={flipped ? "Maxillary tooth" : "Mandibular tooth"}
                  onMouseEnter={() => brushing && handleBrush(i)}
                  onMouseDown={() => handleBrush(i)}
                >
                  {/* Flip vertically with scaleY(-1) */}
                  <div className={`transform ${flipped ? "-scale-y-100" : ""}`} data-idx={i}>
                    <Tooth clean={!hasPlaque} type={type} size="w-10 h-12 md:w-12 md:h-14" />
                  </div>
                </div>
              );
            })}
          </div>
        </Card>
      );
    }

    /* ---------- Level 3: Floss Frenzy (full arch rows; top row flipped) ---------- */
    function FlossFrenzy({ onComplete, onFail }) {
      const gapsPerRow = 9; // 10 teeth per row ‚Üí 9 contacts
      const rows = 2;
      const totalGaps = gapsPerRow * rows;
      const [gaps, setGaps] = useState(() => {
        const arr = Array(totalGaps).fill(false);
        let debris = 12;
        while (debris > 0) {
          const i = Math.floor(Math.random() * totalGaps);
          if (!arr[i]) { arr[i] = true; debris--; }
        }
        return arr;
      });
      const time = useTimer(true, 30, () => onFail?.());
      const cleared = useMemo(() => gaps.filter(v => !v).length, [gaps]);
      const needToClear = totalGaps;

      const flossGap = (i) => setGaps(g => {
        if (!g[i]) return g;
        const copy = [...g]; copy[i] = false; return copy;
      });

      useEffect(() => { if (cleared === needToClear) onComplete?.(); }, [cleared, needToClear, onComplete]);

      const Gap = ({ dirty, onDrag }) => (
        <div
          className={`w-2 h-12 mx-1 rounded-md border transition-all ${
            dirty ? "bg-yellow-300 border-yellow-400" : "bg-white border-gray-300"
          }`}
          onMouseDown={() => onDrag()}
          onMouseEnter={(e) => (e.buttons === 1) && onDrag()}
          onTouchStart={onDrag}
        />
      );

      const Row = ({ rowIndex }) => {
        const start = rowIndex * gapsPerRow;
        const teethCount = gapsPerRow + 1; // 10 teeth
        const flipped = rowIndex === 0;    // flip the top row (maxillary)

        const segments = [];
        for (let t = 0; t < teethCount; t++) {
          const type = PRIMARY_ARCH[t];
          segments.push(
            <div key={`t-${rowIndex}-${t}`} className={`transform ${flipped ? "-scale-y-100" : ""}`}>
              <Tooth size="w-10 h-12 md:w-12 md:h-14" clean type={type} />
            </div>
          );
          if (t < gapsPerRow) {
            const gi = start + t;
            segments.push(
              <div key={`gwrap-${gi}`} className={`flex items-center ${flipped ? "transform -scale-y-100" : ""}`} data-idx={`gap-${gi}`}>
                <Gap dirty={gaps[gi]} onDrag={() => flossGap(gi)} />
              </div>
            );
          }
        }

        return (
          <div
            className="flex items-center justify-center my-2"
            aria-label={flipped ? "Maxillary arch" : "Mandibular arch"}
          >
            {segments}
          </div>
        );
      };

      return (
        <Card
          title="Level 3 ‚Äì Floss Frenzy (Interdental Cleaning)"
          footer={<div>
            <p className="mb-1">Tip: Slide the floss gently between teeth, curve around each tooth in a ‚ÄúC‚Äù shape, and move up & down.</p>
            <p>Goal: Clear all <b>interdental debris</b> (tap/drag on the yellow gaps). Timer is ticking!</p>
          </div>}
        >
          <div className="flex items-center justify-between mb-3">
            <div className="text-sm">Time: <span className="font-semibold">{time}s</span></div>
            <div className="text-sm">Gaps Cleaned: <span className="font-semibold">{cleared}/{totalGaps}</span></div>
          </div>
          <Progress value={(cleared / totalGaps) * 100} />
          <div className="mt-3">
            <Row rowIndex={0} />
            <Row rowIndex={1} />
          </div>
        </Card>
      );
    }

    /* ---------- Level 4: Sealant Splash ---------- */
    function SealantSplash({ onComplete, onFail }) {
      const canvasRef = useRef(null);
      const [coveredPct, setCoveredPct] = useState(0);
      const [painting, setPainting] = useState(false);
      const time = useTimer(true, 35, () => onFail?.());

      useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext("2d");
        const W = canvas.width, H = canvas.height;
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = "#ffffff";
        ctx.strokeStyle = "#cbd5e1";
        ctx.lineWidth = 3;

        ctx.beginPath();
        ctx.moveTo(W * 0.2, H * 0.6);
        ctx.quadraticCurveTo(W * 0.2, H * 0.2, W * 0.5, H * 0.2);
        ctx.quadraticCurveTo(W * 0.8, H * 0.2, W * 0.8, H * 0.6);
        ctx.quadraticCurveTo(W * 0.8, H * 0.85, W * 0.65, H * 0.9);
        ctx.quadraticCurveTo(W * 0.5, H * 0.95, W * 0.35, H * 0.9);
        ctx.quadraticCurveTo(W * 0.2, H * 0.85, W * 0.2, H * 0.6);
        ctx.closePath(); ctx.fill(); ctx.stroke();

        ctx.strokeStyle = "#64748b"; ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(W * 0.3, H * 0.5);
        ctx.bezierCurveTo(W * 0.4, H * 0.45, W * 0.6, H * 0.55, W * 0.7, H * 0.5);
        ctx.moveTo(W * 0.5, H * 0.3);
        ctx.bezierCurveTo(W * 0.5, H * 0.45, W * 0.55, H * 0.6, W * 0.5, H * 0.7);
        ctx.stroke();
      }, []);

      const computeStats = () => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext("2d");
        const W = canvas.width, H = canvas.height;
        const img = ctx.getImageData(0, 0, W, H).data;

        let blueish = 0, white = 0;
        for (let i = 0; i < img.length; i += 4 * 8) {
          const r = img[i], g = img[i + 1], b = img[i + 2], a = img[i + 3];
          if (r > 230 && g > 230 && b > 230) white++;
          if (b > 150 && r < 120 && a > 0) blueish++;
        }
        const pct = Math.min(100, Math.round((blueish / (white + blueish + 1)) * 100));

        const band = 15;
        let vBlue = 0, vTotal = 0, hBlue = 0, hTotal = 0;
        for (let x = Math.floor(W/2 - band); x <= Math.floor(W/2 + band); x++) {
          for (let y = 0; y < H; y++) {
            const idx = (y * W + x) * 4;
            const r = img[idx], g = img[idx+1], b = img[idx+2], a = img[idx+3];
            if (a === 0) continue; vTotal++; if (b > 150 && r < 120) vBlue++;
          }
        }
        for (let y = Math.floor(H/2 - band); y <= Math.floor(H/2 + band); y++) {
          for (let x = 0; x < W; x++) {
            const idx = (y * W + x) * 4;
            const r = img[idx], g = img[idx+1], b = img[idx+2], a = img[idx+3];
            if (a === 0) continue; hTotal++; if (b > 150 && r < 120) hBlue++;
          }
        }
        const isCross = (vBlue/Math.max(1,vTotal)) > 0.35 && (hBlue/Math.max(1,hTotal)) > 0.35;
        return { pct, isCross };
      };

      const paint = (x, y) => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext("2d");
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = "rgba(59,130,246,0.6)";
        ctx.beginPath(); ctx.arc(x, y, 12, 0, Math.PI * 2); ctx.fill();

        const { pct, isCross } = computeStats();
        setCoveredPct(pct);
        if (pct >= 20 || isCross) onComplete?.();
      };

      const handlePointer = (clientX, clientY) => {
        const rect = canvasRef.current.getBoundingClientRect();
        const x = clientX - rect.left, y = clientY - rect.top;
        if (painting) paint(x, y);
      };

      return (
        <Card
          title="Level 4 ‚Äì Sealant Splash"
          footer={<div>
            <p className="mb-1">Fact: Sealants protect deep grooves of molars from food and bacteria.</p>
            <p>Goal: Draw a cross through the center <b>or</b> reach <b>‚â•20%</b> coverage before time runs out.</p>
          </div>}
        >
          <div className="flex items-center justify-between mb-3">
            <div className="text-sm">Time: <span className="font-semibold">{time}s</span></div>
            <div className="text-sm">Coverage: <span className="font-semibold">{coveredPct}%</span></div>
          </div>
          <canvas
            ref={canvasRef}
            width={520}
            height={320}
            className="bg-white rounded-2xl border border-gray-200 touch-none"
            onMouseDown={() => setPainting(true)}
            onMouseUp={() => setPainting(false)}
            onMouseLeave={() => setPainting(false)}
            onMouseMove={(e) => handlePointer(e.clientX, e.clientY)}
            onTouchStart={() => setPainting(true)}
            onTouchEnd={() => setPainting(false)}
            onTouchMove={(e) => {
              const t = e.touches?.[0] || e.changedTouches?.[0];
              if (t) handlePointer(t.clientX, t.clientY);
            }}
          />
          <div className="mt-3 text-sm text-gray-600">Tip: Click or touch and drag to paint the blue sealant.</div>
        </Card>
      );
    }

    /* ---------- Level 5: Checkup Challenge ---------- */
    function CheckupChallenge({ onComplete, onFail }) {
      const [months, setMonths] = useState(Array.from({ length: 12 }, (_, i) => ({ i, appt: false })));
      const [msg, setMsg] = useState("");

      const toggleMonth = (i) => { setMonths(arr => arr.map(m => (m.i === i ? { ...m, appt: !m.appt } : m))); setMsg(""); };

      const validate = () => {
        const picks = months.filter(m => m.appt).map(m => m.i).sort((a,b) => a-b);
        if (picks.length !== 4) { setMsg("Select exactly FOUR checkups for a 3-month interval plan."); onFail?.(); return; }
        for (let k = 0; k < 4; k++) {
          const a = picks[k], b = picks[(k+1)%4];
          const diff = (b - a + 12) % 12;
          if (diff !== 3) { setMsg("Intervals must be exactly 3 months apart."); onFail?.(); return; }
        }
        setMsg("Great plan! Four visits, each 3 months apart.");
        onComplete?.();
      };

      return (
        <Card
          title="Level 5 ‚Äì Checkup Challenge (High-risk = every 3 months)"
          footer={<div>
            <p className="mb-1">Goal: Select <b>exactly four</b> checkups spaced <b>every 3 months</b> (e.g., Jan/Apr/Jul/Oct), then submit.</p>
            <p>Tip: Regular 3-month recalls help with fluoride, sealants, and early detection.</p>
          </div>}
        >
          <div className="grid grid-cols-3 sm:grid-cols-4 gap-2">
            {months.map((m) => (
              <button
                key={m.i}
                onClick={() => toggleMonth(m.i)}
                className={`h-20 rounded-2xl border flex items-center justify-center text-lg font-semibold transition-all ${
                  m.appt ? "bg-emerald-100 border-emerald-400" : "bg-white border-gray-200 hover:bg-gray-50"
                }`}
                aria-label={`Month ${m.i + 1}${m.appt ? " appointment set" : ""}`}
              >
                {new Date(2025, m.i, 1).toLocaleString(undefined, { month: "short" })}
                {m.appt && <span className="ml-2">ü¶∑</span>}
              </button>
            ))}
          </div>
          <div className="mt-4 flex items-center">
            <Button onClick={validate}>Submit Plan</Button>
            {msg && <span className="ml-3 text-sm">{msg}</span>}
          </div>
        </Card>
      );
    }

    const FactBanner = ({ text }) => (
      <div className="bg-amber-50 border border-amber-200 text-amber-900 p-3 rounded-xl text-sm">{text}</div>
    );

    /* ---------- App Shell ---------- */
    function CariesPreventionGame() {
      const [level, setLevel] = useState(0); // 0..5 (five levels)
      const [score, setScore] = useState(0);
      const [showHowTo, setShowHowTo] = useState(true);
      const next = () => setLevel(l => l + 1);

      return (
        <div className="min-h-screen w-full bg-gradient-to-b from-sky-50 to-white flex flex-col items-center px-4 py-8">
          <div className="w-full max-w-4xl flex items-center justify-between mb-6">
            <h1 className="text-2xl sm:text-3xl font-bold tracking-tight">Caries Prevention Quest</h1>
            <div className="text-sm text-gray-600">Score: <span className="font-semibold">{score}</span></div>
          </div>

          {showHowTo && (
            <Card title="How to Play">
              <ul className="list-disc ml-6 text-sm text-gray-700 space-y-1">
                <li><b>Level 1 ‚Äì Candy Crack:</b> Drop candy to make cracks, then brush side‚Äëto‚Äëside to clean back to 0.</li>
                <li><b>Level 2 ‚Äì Brush Boss:</b> 20 primary teeth (2√ó10). Clean the 10 yellow ones.</li>
                <li><b>Level 3 ‚Äì Floss Frenzy:</b> Full arch per row ‚Äî clear all interdental debris.</li>
                <li><b>Level 4 ‚Äì Sealant Splash:</b> Draw a cross through the center or reach ‚â•20% coverage.</li>
                <li><b>Level 5 ‚Äì Checkup Challenge:</b> High‚Äërisk = exactly four visits, every 3 months.</li>
              </ul>
              <div className="mt-4"><Button onClick={() => setShowHowTo(false)} variant="success">Start</Button></div>
            </Card>
          )}

          {!showHowTo && level === 0 && (
            <CandyCrack
              onComplete={() => { setScore(s => s + 80); next(); }}
            />
          )}

          {level === 1 && (
            <BrushBoss
              onComplete={() => { setScore(s => s + 100); next(); }}
              onFail={() => { setScore(s => Math.max(0, s - 20)); next(); }}
            />
          )}

          {level === 2 && (
            <div className="w-full flex flex-col items-center gap-4">
              <FactBanner text="Floss once a day. Slide between teeth, curve around each tooth in a ‚ÄúC‚Äù shape, and move up & down." />
              <FlossFrenzy
                onComplete={() => { setScore(s => s + 100); next(); }}
                onFail={() => { setScore(s => Math.max(0, s - 20)); next(); }}
              />
            </div>
          )}

          {level === 3 && (
            <div className="w-full flex flex-col items-center gap-4">
              <FactBanner text="Sealants coat the deep grooves of molars and can dramatically reduce cavities." />
              <SealantSplash
                onComplete={() => { setScore(s => s + 120); next(); }}
                onFail={() => { setScore(s => Math.max(0, s - 20)); next(); }}
              />
            </div>
          )}

          {level === 4 && (
            <div className="w-full flex flex-col items-center gap-4">
              <FactBanner text="High-risk children often need recall every 3 months for fluoride, sealants, and early detection." />
              <CheckupChallenge
                onComplete={() => { setScore(s => s + 80); next(); }}
                onFail={() => { setScore(s => Math.max(0, s - 20)); }}
              />
            </div>
          )}

          {level >= 5 && (
            <Card title="You Did It!">
              <p className="text-gray-700">
                You mastered <b>candy risk</b>, <b>brushing</b>, <b>flossing</b>, <b>sealants</b>, and <b>regular checkups</b>.
              </p>
              <ul className="list-disc ml-6 mt-3 text-gray-700 text-sm">
                <li>Limit sugary snacks; rinse or brush after treats.</li>
                <li>Brush 2√ó/day for 2 minutes with fluoride toothpaste.</li>
                <li>Floss once a day to clean where brushes can‚Äôt reach.</li>
                <li>Ask about sealants for new molars.</li>
                <li>High-risk recall: every 3 months.</li>
              </ul>
              <div className="mt-4 flex items-center">
                <Button onClick={() => { window.location.reload(); }}>Play Again</Button>
                <Button variant="ghost" onClick={() => window.print()}>Print Tips</Button>
              </div>
            </Card>
          )}

          <footer className="mt-8 text-xs text-gray-500">WesternU Dental Medicine.</footer>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<CariesPreventionGame />);
  </script>
</body>
</html>
