<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Caries Prevention Quest</title>
  <meta name="description" content="Kid‑friendly web game: candy cracks, OHI, floss, sealants, and regular visits." />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html,body{height:100%}
    .no-select{user-select:none;-webkit-user-select:none}
  </style>
</head>
<body class="bg-sky-50">
  <div id="root"></div>

  <!-- React + Babel (UMD) -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    /* -------------------------------------------
       Tooth SVGs (primary dentition silhouettes)
       ------------------------------------------- */
    const PRIMARY_ARCH = [
      "secondMolar","firstMolar","canine","lateralIncisor","centralIncisor",
      "centralIncisor","lateralIncisor","canine","firstMolar","secondMolar"
    ];
    const ANTERIOR_ARCH = [ // central, lateral, canine (R to L mirrored)
      "canine","lateralIncisor","centralIncisor",
      "centralIncisor","lateralIncisor","canine"
    ];

    function pathForTooth(type){
      // Simple, kid-friendly silhouettes (viewBox 0 0 100 120)
      switch(type){
        case "centralIncisor":
          return "M50 6 C36 6,22 20,22 38 C22 60,36 64,38 78 C42 96,48 112,50 112 C52 112,58 96,62 78 C64 64,78 60,78 38 C78 20,64 6,50 6 Z";
        case "lateralIncisor":
          return "M50 8 C38 8,26 22,26 40 C26 58,36 62,38 76 C41 92,47 110,50 110 C53 110,59 92,62 76 C64 62,74 58,74 40 C74 22,62 8,50 8 Z";
        case "canine":
          return "M50 4 C42 10,30 26,28 42 C26 58,36 68,38 82 C42 100,48 112,50 112 C52 112,58 100,62 82 C64 68,74 58,72 42 C70 26,58 10,50 4 Z";
        case "firstMolar":
          return "M30 18 C22 18,18 30,18 42 C18 58,30 70,36 82 C40 92,44 108,50 108 C56 108,60 92,64 82 C70 70,82 58,82 42 C82 30,78 18,70 18 C60 12,40 12,30 18 Z";
        case "secondMolar":
        default:
          return "M26 20 C18 20,14 32,14 44 C14 62,28 72,34 86 C38 98,44 110,50 110 C56 110,62 98,66 86 C72 72,86 62,86 44 C86 32,82 20,74 20 C62 12,38 12,26 20 Z";
      }
    }

    const Tooth = ({ clean = false, size="w-10 h-12", type="firstMolar", label }) => {
      const d = pathForTooth(type);
      const stroke = clean ? "#cbd5e1" : "#f59e0b";
      return (
        <svg
          viewBox="0 0 100 120"
          className={`${size} m-0.5 drop-shadow-sm`}
          role="img"
          aria-label={label || `${type} ${clean ? "clean" : "needs cleaning"}`}
        >
          <defs>
            <radialGradient id="shine" cx="45%" cy="28%" r="60%">
              <stop offset="0%" stopColor="#ffffff"/>
              <stop offset="70%" stopColor={clean ? "#f3f6fb" : "#fef3c7"}/>
              <stop offset="100%" stopColor={clean ? "#e5edf7" : "#fde68a"}/>
            </radialGradient>
          </defs>
          <path d={d} fill={clean ? "url(#shine)" : "#fde68a"} stroke={stroke} strokeWidth="2"/>
          {/* Minimal surface lines */}
          {type.includes("Incisor") && (
            <path d="M30 44 C40 38,60 38,70 44" stroke={clean ? "#94a3b8" : "#b45309"} strokeWidth="2" fill="none" opacity="0.35" />
          )}
          {type === "canine" && (
            <path d="M35 46 C50 36,65 46,65 46" stroke={clean ? "#94a3b8" : "#b45309"} strokeWidth="2" fill="none" opacity="0.35" />
          )}
          {type.includes("Molar") && (
            <path d="M28 48 C42 38,58 58,72 48 M50 30 C52 46,52 62,50 76"
                  stroke={clean ? "#94a3b8" : "#b45309"} strokeWidth="2" fill="none" opacity="0.45" />
          )}
        </svg>
      );
    };

    /* --------- Shared UI --------- */
    const Progress = ({ value }) => (
      <div className="w-full bg-gray-200 rounded-full h-3">
        <div className="h-3 rounded-full transition-all bg-blue-500" style={{ width: `${Math.min(100, Math.max(0, value))}%` }} />
      </div>
    );

    const Card = ({ title, children, footer }) => (
      <div className="bg-white rounded-2xl shadow-lg p-5 border border-gray-100 w-full max-w-4xl">
        <div className="flex items-center justify-between">
          <h2 className="text-xl font-semibold mb-3">{title}</h2>
        </div>
        <div>{children}</div>
        {footer && <div className="mt-4 text-sm text-gray-600">{footer}</div>}
      </div>
    );

    const Button = ({ children, onClick, variant = "default", disabled }) => (
      <button
        onClick={onClick}
        disabled={disabled}
        className={`px-4 py-2 rounded-xl font-medium shadow-sm transition-all mr-2 mb-2 ${
          variant === "default"
            ? "bg-blue-600 text-white hover:bg-blue-700 disabled:bg-blue-300"
            : variant === "ghost"
            ? "bg-white border border-gray-300 hover:bg-gray-50"
            : variant === "success"
            ? "bg-emerald-600 text-white hover:bg-emerald-700 disabled:bg-emerald-300"
            : "bg-slate-800 text-white hover:bg-slate-900"
        }`}
      >
        {children}
      </button>
    );

    function useTimer(active, seconds, onDone) {
      const [time, setTime] = useState(seconds);
      useEffect(() => { if (active) setTime(seconds); }, [seconds, active]);
      useEffect(() => {
        if (!active) return;
        const id = setInterval(() => {
          setTime(t => {
            if (t <= 1) { clearInterval(id); onDone?.(); return 0; }
            return t - 1;
          });
        }, 1000);
        return () => clearInterval(id);
      }, [active, onDone]);
      return time;
    }

    /* -----------------------------------------
       Level 1: Candy Crack (robust brush loop)
       ----------------------------------------- */
    function CandyCrack({ onComplete }) {
      const sceneRef = useRef(null);

      // logical state
      const [hits, setHits] = useState(0);
      const [severity, setSeverity] = useState(0);
      const [played, setPlayed] = useState(false);
      const [brushing, setBrushing] = useState(false);
      const [cap, setCap] = useState("Drop a candy onto the tooth.");
      const canNext = played && severity === 0;

      // refs
      const hitsRef = useRef(0);
      const sevRef  = useRef(0);
      const brushIntervalRef = useRef(null);
      useEffect(() => { hitsRef.current = hits; }, [hits]);
      useEffect(() => { sevRef.current  = severity; }, [severity]);

      // smoothed bar
      const [sevBar, setSevBar] = useState(0);
      const sevBarRef = useRef(0);
      const sevAnimRef = useRef(null);
      useEffect(() => {
        if (sevAnimRef.current) cancelAnimationFrame(sevAnimRef.current);
        const step = () => {
          const target = sevRef.current;
          const curr   = sevBarRef.current;
          const diff   = target - curr;
          if (Math.abs(diff) < 0.2) { sevBarRef.current = target; setSevBar(target); sevAnimRef.current = null; return; }
          const next = curr + diff * 0.2;
          sevBarRef.current = next; setSevBar(next);
          sevAnimRef.current = requestAnimationFrame(step);
        };
        sevAnimRef.current = requestAnimationFrame(step);
        return () => sevAnimRef.current && cancelAnimationFrame(sevAnimRef.current);
      }, [severity]);

      // cache DOM nodes
      const els = useRef({});
      useEffect(() => {
        const scene = sceneRef.current;
        const toothSVG = scene.querySelector("#toothSVG");
        els.current = {
          scene, toothSVG,
          cracks: scene.querySelector("#cracks"),
          pit: scene.querySelector("#pit"),
          mainCrack: scene.querySelector("#mainCrack"),
          branch1: scene.querySelector("#branch1"),
          branch2: scene.querySelector("#branch2"),
          branch3: scene.querySelector("#branch3"),
          plaque: scene.querySelector("#plaque"),
          brush: scene.querySelector("#brush"),
          foam: scene.querySelector("#foam"),
        };
        applyCrackVisuals(0, 0);
      }, []);

      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

      function flashImpact(pxX, pxY) {
        const { toothSVG } = els.current;
        if (!toothSVG) return;
        const pt = toothSVG.createSVGPoint();
        pt.x = pxX; pt.y = pxY;
        const p = pt.matrixTransform(toothSVG.getScreenCTM().inverse());
        const circ = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circ.setAttribute("cx", p.x);
        circ.setAttribute("cy", 110);
        circ.setAttribute("r", 3);
        circ.setAttribute("fill", "#fff");
        circ.setAttribute("opacity", "0.9");
        toothSVG.appendChild(circ);
        circ.animate([{opacity:0.9,r:3},{opacity:0.0,r:22}],{duration:280,easing:'ease-out'}).onfinish=()=>circ.remove();
      }

      function applyCrackVisuals(nextSeverity, nextHits) {
        const { cracks, pit, mainCrack, branch1, branch2, branch3 } = els.current;
        if (!cracks || !pit) return;
        const s = clamp(nextSeverity, 0, 100);

        if (s <= 0 && nextHits === 0) {
          cracks.style.opacity = "0";
          pit.setAttribute("opacity","0.0");
          pit.setAttribute("r","0.1");
          [branch1, branch2, branch3].forEach(p=>p && (p.style.opacity="0"));
          [mainCrack, branch1, branch2, branch3].forEach(p=>p && (p.style.strokeWidth="1.4"));
          cracks.style.stroke = "#4b3b34";
          return;
        }

        cracks.style.opacity = s > 0 ? "1" : "0.0001";
        const sw = 1.4 + (s/100)*3.8;
        [mainCrack, branch1, branch2, branch3].forEach(p=>p && (p.style.strokeWidth = sw.toFixed(2)));

        // darken with severity
        const r = Math.round(0x4b + (0x1a-0x4b)*(s/100));
        const g = Math.round(0x3b + (0x14-0x3b)*(s/100));
        const b = Math.round(0x34 + (0x12-0x34)*(s/100));
        cracks.style.stroke = `rgb(${r},${g},${b})`;

        branch1.style.opacity = s > 20 ? "1" : "0";
        branch2.style.opacity = s > 45 ? "1" : "0";
        branch3.style.opacity = s > 70 ? "1" : "0";

        const pitR = 0.5 + (s/100)*10;
        pit.setAttribute("r", pitR.toFixed(2));
        pit.setAttribute("opacity", s > 0 ? Math.min(0.85, 0.2 + (s/100)).toFixed(2) : "0.0");
      }

      function applyImpact(deltaSev = 9) {
        const nh = hitsRef.current + 1;
        const ns = clamp(sevRef.current + deltaSev, 0, 100);
        setHits(nh); setSeverity(ns); setPlayed(true);
        hitsRef.current = nh; sevRef.current = ns;

        const { plaque } = els.current;
        if (plaque) plaque.style.opacity = String(Math.min(0.45, 0.10 + nh * 0.03));
        applyCrackVisuals(ns, nh);
      }

      function impactAt(pxX, pxY) {
        setCap("Ouch! The crack deepens and darkens.");
        applyImpact(9);
        flashImpact(pxX, pxY);
      }

      function dropCandy() {
        const { scene } = els.current;
        if (!scene) return;
        const rect = scene.getBoundingClientRect();
        const minX = rect.width*0.23, maxX = rect.width*0.77;
        const left = minX + Math.random()*(maxX-minX);

        const c = document.createElement("div");
        c.className = "absolute w-7 h-7 rounded-full";
        c.style.background = "repeating-linear-gradient(45deg,#ff7aa2 0 7px,#ffd4e3 7px 14px)";
        c.style.boxShadow = "inset 0 0 6px rgba(0,0,0,.3)";
        c.style.left = left + "px";
        c.style.top  = "-18px";
        c.style.borderRadius = "50%";
        c.style.transform = "translate(-50%,-50%) rotate(0deg)";
        scene.appendChild(c);

        let y = -18, vy = 1 + Math.random()*0.7, rot = 0;
        const g = 0.28, targetY = rect.height*0.28;

        const tick = () => {
          vy += g; y += vy; rot += 6 + Math.random()*2;
          c.style.transform = `translate(-50%,-50%) translateY(${y}px) rotate(${rot}deg)`;
          if (y >= targetY) {
            c.style.transition = "opacity .16s ease"; c.style.opacity = "0";
            impactAt(left, targetY);
            setTimeout(()=>c.remove(), 180);
            return;
          }
          requestAnimationFrame(tick);
        };
        requestAnimationFrame(tick);
      }

      function resetAll() {
        setHits(0); setSeverity(0); hitsRef.current=0; sevRef.current=0;
        setPlayed(false); setBrushing(false); setCap("Reset. Drop a candy onto the tooth.");
        if (brushIntervalRef.current){ clearInterval(brushIntervalRef.current); brushIntervalRef.current = null; }
        const { cracks, pit, plaque, mainCrack, branch1, branch2, branch3, brush } = els.current;
        if (cracks) cracks.style.opacity = "0";
        if (pit) { pit.setAttribute("r","0.1"); pit.setAttribute("opacity","0.0"); }
        if (plaque) plaque.style.opacity = "0.10";
        [mainCrack,branch1,branch2,branch3].forEach(p=>p && (p.style.strokeWidth="1.4"));
        if (brush) { brush.style.opacity = "0"; brush.style.transform = "translateX(0) rotate(0deg)"; }
      }

      // ✅ robust brush loop using setInterval (never adds damage)
      function runBrush() {
        const { scene, brush, foam, plaque } = els.current;
        if (!scene || !brush) return;
        if (brushing) return;
        setBrushing(true);

        // show brush
        const rect = scene.getBoundingClientRect();
        brush.style.opacity = "1";
        brush.style.transition = "none";
        brush.style.left = `${rect.width/2 - 80}px`;
        brush.style.top  = `${rect.height*0.22}px`;

        // motion state
        let offset = 0, dir = 1;
        const maxSwing = 34, speed = 3.4;

        // short “buff” animation even if already clean
        const cleanBuffMs = 1800;
        const start = Date.now();

        if (brushIntervalRef.current) clearInterval(brushIntervalRef.current);

        brushIntervalRef.current = setInterval(() => {
          // move brush
          offset += dir * speed;
          if (offset > maxSwing || offset < -maxSwing) dir *= -1;
          const tilt = (offset / maxSwing) * 6;
          brush.style.transform = `translateX(${offset}px) rotate(${tilt}deg)`;
          if (foam) {
            const pulsate = 0.25 + 0.5 * Math.abs(Math.sin(offset * 0.12));
            foam.style.opacity = pulsate.toFixed(2);
          }

          // scrub severity down if needed
          if (sevRef.current > 0) {
            const ns = Math.max(0, sevRef.current - 0.28);
            setSeverity(ns);
            sevRef.current = ns;
            applyCrackVisuals(ns, hitsRef.current);

            if (plaque) {
              const curr = parseFloat(plaque.style.opacity || "0.10");
              plaque.style.opacity = String(Math.max(0.05, curr - 0.004));
            }
          }

          const stillDirty = sevRef.current > 0;
          const stillBuffing = Date.now() - start < cleanBuffMs;
          if (!stillDirty && !stillBuffing) finishBrushing();
        }, 16); // ~60fps

        setCap("Brushing… small circles!");

        function finishBrushing(){
          if (brushIntervalRef.current) {
            clearInterval(brushIntervalRef.current);
            brushIntervalRef.current = null;
          }
          brush.style.opacity = "0";
          brush.style.transform = "translateX(0) rotate(0deg)";
          setBrushing(false);
          setCap("All clean — minty fresh! 🪥");
        }
      }

      const hitPct = Math.min(100, hits * 8);
      const severityPct = Math.min(100, Math.max(0, sevBar));

      return (
        <Card
          title="Level 1 – Candy Crack (Cause & Clean)"
          footer={<div>
            <p className="mb-1">Goal: Drop candy to make cracks, then brush side‑to‑side to reduce severity back to <b>0</b>.</p>
            <p>Unlock <b>Next Level</b> after you’ve dropped candy at least once and fully cleaned the tooth.</p>
          </div>}
        >
          <div className="flex flex-wrap items-center gap-2 mb-4">
            <Button onClick={dropCandy}>🍬 Drop Candy</Button>
            <Button variant="ghost" onClick={runBrush}>🪥 Toothbrush</Button>
            <Button variant="ghost" onClick={resetAll}>Reset</Button>
            <Button variant="success" disabled={!canNext} onClick={() => onComplete?.()}>Next Level ▶</Button>
            <span className="text-sm text-gray-600">{cap}</span>
          </div>

          {/* HUD */}
          <div className="grid grid-cols-2 gap-4 mb-3">
            <div>
              <div className="flex items-center justify-between text-xs text-gray-600 mb-1">
                <span>Candy hits</span><span className="font-semibold">{hits}</span>
              </div>
              <div className="w-full bg-gray-200 rounded-full h-3">
                <div className="h-3 rounded-full bg-cyan-500 transition-all" style={{width:`${hitPct}%`}} />
              </div>
            </div>
            <div>
              <div className="flex items-center justify-between text-xs text-gray-600 mb-1">
                <span>Crack severity</span><span className="font-semibold">{Math.round(severity)}</span>
              </div>
              <div className="w-full bg-gray-200 rounded-full h-3">
                <div className="h-3 rounded-full bg-rose-500" style={{width:`${severityPct.toFixed(1)}%`}} />
              </div>
            </div>
          </div>

          {/* Scene */}
          <div ref={sceneRef} className="relative h-[420px] rounded-2xl overflow-hidden bg-gradient-to-b from-sky-100 to-sky-200 border border-sky-300">
            <div className="absolute left-3 bottom-3 bg-white/80 text-slate-800 text-sm px-3 py-2 rounded-xl border border-white">
              {cap}
            </div>

            <svg id="toothSVG" viewBox="0 0 400 360" className="w-full h-full">
              <defs>
                <radialGradient id="enamelGrad" cx="50%" cy="35%" r="65%">
                  <stop offset="0%" stopColor="#ffffff"/><stop offset="70%" stopColor="#f3f6fb"/><stop offset="100%" stopColor="#e6ebf2"/>
                </radialGradient>
                <filter id="soft" x="-40%" y="-40%" width="180%" height="180%"><feGaussianBlur stdDeviation="6"/></filter>
              </defs>

              <path id="plaque" d="M200 48 C160 30,114 62,118 116 C122 170,152 188,164 226 C176 266,184 308,200 308
                                    C216 308,224 266,236 226 C248 188,278 170,282 116 C286 62,240 30,200 48 Z"
                    fill="#e8d57a" opacity="0.10" filter="url(#soft)"></path>

              <path d="M200 48 C160 30,114 62,118 116 C122 170,152 188,164 226 C176 266,184 308,200 308
                       C216 308,224 266,236 226 C248 188,278 170,282 116 C286 62,240 30,200 48 Z"
                    fill="url(#enamelGrad)" stroke="#d1d9e6" strokeWidth="1.2"></path>

              <g id="cracks" fill="none" stroke="#4b3b34" strokeLinecap="round" strokeLinejoin="round" opacity="0.0">
                <path id="mainCrack" d="M190 115 C 196 126, 202 140, 208 154 C 210 160, 206 170, 212 182"/>
                <path id="branch1" d="M202 138 C 190 146, 182 154, 176 162" opacity="0"/>
                <path id="branch2" d="M206 152 C 220 160, 230 168, 236 176" opacity="0"/>
                <path id="branch3" d="M196 132 C 188 124, 180 120, 172 118" opacity="0"/>
              </g>

              <circle id="pit" cx="206" cy="152" r="0.1" fill="#3b2b25" opacity="0.0"></circle>
            </svg>

            <div id="brush" className="absolute left-[-9999px] top-0 opacity-0 w-40 h-9 rounded-lg bg-blue-500 shadow-md flex items-center pl-4 gap-2 will-change-transform">
              <div className="w-20 h-4 bg-blue-200 rounded"></div>
              <div id="foam" className="absolute left-16 top-1 w-20 h-6 rounded-full bg-white/80 blur-[1px] opacity-0"></div>
            </div>
          </div>
        </Card>
      );
    }

    /* -----------------------------------------
       Level 2: Brush Boss (teeth turn white)
       ----------------------------------------- */
    function BrushBoss({ onComplete, onFail }) {
      // 20 teeth (2 rows × 10); randomize 10 dirty
      const cols = 10, rows = 2, total = cols * rows;
      const [grid, setGrid] = useState(() => {
        const arr = Array(total).fill(false);
        let dirty = 10;
        while (dirty > 0) {
          const i = Math.floor(Math.random() * total);
          if (!arr[i]) { arr[i] = true; dirty--; }
        }
        return arr;
      });
      const cleaned = useMemo(() => 10 - grid.filter(Boolean).length, [grid]);
      const time = useTimer(true, 30, () => onFail?.());
      const [brushing, setBrushing] = useState(false);

      const cleanIndex = (idx) => {
        setGrid(g => {
          if (!g[idx]) return g;           // already clean
          const copy = g.slice();          // new array → triggers re-render
          copy[idx] = false;               // mark clean
          return copy;
        });
      };

      useEffect(() => { if (cleaned >= 10) onComplete?.(); }, [cleaned, onComplete]);

      return (
        <Card
          title="Level 2 – Brush Boss (OHI)"
          footer={<div>
            <p className="mb-1">Tip: Brush all surfaces in small circles for 2 minutes, twice a day.</p>
            <p>Goal: Clean the <b>10 yellow teeth</b>.</p>
          </div>}
        >
          <div className="flex items-center justify-between mb-3">
            <div className="text-sm">Time: <span className="font-semibold">{time}s</span></div>
            <div className="text-sm">Cleaned: <span className="font-semibold">{cleaned}/10</span></div>
          </div>
          <Progress value={(cleaned / 10) * 100} />

          <div
            className="select-none grid mt-3 gap-1"
            style={{ gridTemplateColumns: `repeat(${cols}, minmax(0, 1fr))` }}
            onMouseDown={() => setBrushing(true)}
            onMouseUp={() => setBrushing(false)}
            onMouseLeave={() => setBrushing(false)}
            onTouchStart={() => setBrushing(true)}
            onTouchEnd={() => setBrushing(false)}
          >
            {grid.map((hasPlaque, i) => {
              const col = i % cols;
              const row = Math.floor(i / cols);     // 0 = top (maxillary), 1 = bottom (mandibular)
              const type = PRIMARY_ARCH[col];
              const flipped = row === 0;            // flip top row
              return (
                <div
                  key={i}
                  className="flex items-center justify-center"
                  data-idx={i}
                  onMouseEnter={() => brushing && cleanIndex(i)}
                  onMouseDown={() => cleanIndex(i)}
                  onTouchMove={(e) => {
                    const t = e.touches?.[0] || e.changedTouches?.[0];
                    if (!t) return;
                    const el = document.elementFromPoint(t.clientX, t.clientY);
                    const idx = Number(el?.dataset?.idx);
                    if (!Number.isNaN(idx)) cleanIndex(idx);
                  }}
                >
                  <div className={`transform ${flipped ? "-scale-y-100" : ""}`} data-idx={i}>
                    <Tooth clean={!hasPlaque} type={type} size="w-10 h-12 md:w-12 md:h-14" />
                  </div>
                </div>
              );
            })}
          </div>
        </Card>
      );
    }

    /* -------------------------------------------------------------
       Level 3: Floss Frenzy (anterior only: 6 upper + 6 lower)
       ------------------------------------------------------------- */
    function FlossFrenzy({ onComplete, onFail }) {
      const gapsPerRow = 5;         // 6 anterior teeth → 5 contacts
      const rows = 2;
      const totalGaps = gapsPerRow * rows;

      const [gaps, setGaps] = useState(() => {
        const arr = Array(totalGaps).fill(false);
        let debris = 6;             // start with 6 debris pieces
        while (debris > 0) {
          const i = Math.floor(Math.random() * totalGaps);
          if (!arr[i]) { arr[i] = true; debris--; }
        }
        return arr;
      });

      const time = useTimer(true, 25, () => onFail?.());
      const cleared = useMemo(() => gaps.filter(v => !v).length, [gaps]);

      const flossGap = (i) => setGaps(g => {
        if (!g[i]) return g;
        const copy = g.slice();
        copy[i] = false;
        return copy;
      });

      useEffect(() => {
        if (cleared === totalGaps) onComplete?.();
      }, [cleared, totalGaps, onComplete]);

      const Gap = ({ dirty, onDrag, idx }) => (
        <div
          className={`w-2 h-12 mx-1 rounded-md border transition-all ${dirty ? "bg-yellow-300 border-yellow-400" : "bg-white border-gray-300"}`}
          onMouseDown={onDrag}
          onMouseEnter={(e) => (e.buttons === 1) && onDrag()}
          onTouchStart={onDrag}
          data-idx={idx}
        />
      );

      const Row = ({ rowIndex }) => {
        const start = rowIndex * gapsPerRow;
        const flipped = rowIndex === 0;   // flip top row (maxillary)
        const segments = [];
        for (let t = 0; t < 6; t++) {
          const type = ANTERIOR_ARCH[t];
          segments.push(
            <div key={`t-${rowIndex}-${t}`} className={`transform ${flipped ? "-scale-y-100" : ""}`}>
              <Tooth size="w-9 h-11 md:w-11 md:h-13" clean type={type} />
            </div>
          );
          if (t < 5) {
            const gi = start + t;
            segments.push(
              <div key={`gwrap-${gi}`} className={`flex items-center ${flipped ? "transform -scale-y-100" : ""}`}>
                <Gap dirty={gaps[gi]} idx={gi} onDrag={() => flossGap(gi)} />
              </div>
            );
          }
        }
        return (
          <div className="flex items-center justify-center my-1">{segments}</div>
        );
      };

      return (
        <Card
          title="Level 3 – Floss Frenzy (Anterior Only)"
          footer={<div>
            <p className="mb-1">Tip: Slide floss gently, wrap in a “C” shape, and move up & down.</p>
            <p>Goal: Clear all <b>contacts</b> between the 6 upper and 6 lower anterior teeth.</p>
          </div>}
        >
          <div className="flex items-center justify-between mb-3">
            <div className="text-sm">Time: <span className="font-semibold">{time}s</span></div>
            <div className="text-sm">Gaps Cleaned: <span className="font-semibold">{cleared}/{totalGaps}</span></div>
          </div>
          <Progress value={(cleared / totalGaps) * 100} />
          <div className="mt-3 overflow-x-auto no-select">
            <Row rowIndex={0} />
            <Row rowIndex={1} />
          </div>
        </Card>
      );
    }

    /* -------------------------------
       Level 4: Sealant Splash (same)
       ------------------------------- */
    function SealantSplash({ onComplete, onFail }) {
      const canvasRef = useRef(null);
      const [coveredPct, setCoveredPct] = useState(0);
      const [painting, setPainting] = useState(false);
      const time = useTimer(true, 35, () => onFail?.());

      useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext("2d");
        const W = canvas.width, H = canvas.height;
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = "#ffffff";
        ctx.strokeStyle = "#cbd5e1";
        ctx.lineWidth = 3;

        ctx.beginPath();
        ctx.moveTo(W * 0.2, H * 0.6);
        ctx.quadraticCurveTo(W * 0.2, H * 0.2, W * 0.5, H * 0.2);
        ctx.quadraticCurveTo(W * 0.8, H * 0.2, W * 0.8, H * 0.6);
        ctx.quadraticCurveTo(W * 0.8, H * 0.85, W * 0.65, H * 0.9);
        ctx.quadraticCurveTo(W * 0.5, H * 0.95, W * 0.35, H * 0.9);
        ctx.quadraticCurveTo(W * 0.2, H * 0.85, W * 0.2, H * 0.6);
        ctx.closePath(); ctx.fill(); ctx.stroke();

        ctx.strokeStyle = "#64748b"; ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(W * 0.3, H * 0.5);
        ctx.bezierCurveTo(W * 0.4, H * 0.45, W * 0.6, H * 0.55, W * 0.7, H * 0.5);
        ctx.moveTo(W * 0.5, H * 0.3);
        ctx.bezierCurveTo(W * 0.5, H * 0.45, W * 0.55, H * 0.6, W * 0.5, H * 0.7);
        ctx.stroke();
      }, []);

      const computeStats = () => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext("2d");
        const W = canvas.width, H = canvas.height;
        const img = ctx.getImageData(0, 0, W, H).data;

        let blueish = 0, white = 0;
        for (let i = 0; i < img.length; i += 4 * 8) {
          const r = img[i], g = img[i + 1], b = img[i + 2], a = img[i + 3];
          if (r > 230 && g > 230 && b > 230) white++;
          if (b > 150 && r < 120 && a > 0) blueish++;
        }
        const pct = Math.min(100, Math.round((blueish / (white + blueish + 1)) * 100));

        // crude cross detection
        const band = 15;
        let vBlue = 0, vTotal = 0, hBlue = 0, hTotal = 0;
        for (let x = Math.floor(W/2 - band); x <= Math.floor(W/2 + band); x++) {
          for (let y = 0; y < H; y++) {
            const idx = (y * W + x) * 4;
            const r = img[idx], g = img[idx+1], b = img[idx+2], a = img[idx+3];
            if (a === 0) continue; vTotal++; if (b > 150 && r < 120) vBlue++;
          }
        }
        for (let y = Math.floor(H/2 - band); y <= Math.floor(H/2 + band); y++) {
          for (let x = 0; x < W; x++) {
            const idx = (y * W + x) * 4;
            const r = img[idx], g = img[idx+1], b = img[idx+2], a = img[idx+3];
            if (a === 0) continue; hTotal++; if (b > 150 && r < 120) hBlue++;
          }
        }
        const isCross = (vBlue/Math.max(1,vTotal)) > 0.35 && (hBlue/Math.max(1,hTotal)) > 0.35;
        return { pct, isCross };
      };

      const paint = (x, y) => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext("2d");
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = "rgba(59,130,246,0.6)";
        ctx.beginPath(); ctx.arc(x, y, 12, 0, Math.PI * 2); ctx.fill();

        const { pct, isCross } = computeStats();
        setCoveredPct(pct);
        if (pct >= 20 || isCross) onComplete?.();
      };

      const handlePointer = (clientX, clientY) => {
        const rect = canvasRef.current.getBoundingClientRect();
        const x = clientX - rect.left, y = clientY - rect.top;
        if (painting) paint(x, y);
      };

      return (
        <Card
          title="Level 4 – Sealant Splash"
          footer={<div>
            <p className="mb-1">Fact: Sealants protect deep grooves of molars.</p>
            <p>Goal: Draw a cross through the center <b>or</b> reach <b>≥20%</b> coverage before time runs out.</p>
          </div>}
        >
          <div className="flex items-center justify-between mb-3">
            <div className="text-sm">Time: <span className="font-semibold">{time}s</span></div>
            <div className="text-sm">Coverage: <span className="font-semibold">{coveredPct}%</span></div>
          </div>
          <canvas
            ref={canvasRef}
            width={520}
            height={320}
            className="bg-white rounded-2xl border border-gray-200 touch-none"
            onMouseDown={() => setPainting(true)}
            onMouseUp={() => setPainting(false)}
            onMouseLeave={() => setPainting(false)}
            onMouseMove={(e) => handlePointer(e.clientX, e.clientY)}
            onTouchStart={() => setPainting(true)}
            onTouchEnd={() => setPainting(false)}
            onTouchMove={(e) => {
              const t = e.touches?.[0] || e.changedTouches?.[0];
              if (t) handlePointer(t.clientX, t.clientY);
            }}
          />
          <div className="mt-3 text-sm text-gray-600">Tip: Tap or drag to paint the blue sealant.</div>
        </Card>
      );
    }

    /* --------------------------------
       Level 5: Checkup Challenge (same)
       -------------------------------- */
    function CheckupChallenge({ onComplete, onFail }) {
      const [months, setMonths] = useState(Array.from({ length: 12 }, (_, i) => ({ i, appt: false })));
      const [msg, setMsg] = useState("");

      const toggleMonth = (i) => { setMonths(arr => arr.map(m => (m.i === i ? { ...m, appt: !m.appt } : m))); setMsg(""); };

      const validate = () => {
        const picks = months.filter(m => m.appt).map(m => m.i).sort((a,b) => a-b);
        if (picks.length !== 4) { setMsg("Select exactly FOUR checkups for a 3‑month interval plan."); onFail?.(); return; }
        for (let k = 0; k < 4; k++) {
          const a = picks[k], b = picks[(k+1)%4];
          const diff = (b - a + 12) % 12;
          if (diff !== 3) { setMsg("Intervals must be exactly 3 months apart."); onFail?.(); return; }
        }
        setMsg("Great plan! Four visits, each 3 months apart.");
        onComplete?.();
      };

      return (
        <Card
          title="Level 5 – Checkup Challenge (High‑risk = every 3 months)"
          footer={<div>
            <p className="mb-1">Goal: Choose <b>four</b> months, exactly 3 apart (e.g., Jan/Apr/Jul/Oct).</p>
          </div>}
        >
          <div className="grid grid-cols-3 sm:grid-cols-4 gap-2">
            {months.map((m) => (
              <button
                key={m.i}
                onClick={() => toggleMonth(m.i)}
                className={`h-20 rounded-2xl border flex items-center justify-center text-lg font-semibold transition-all ${
                  m.appt ? "bg-emerald-100 border-emerald-400" : "bg-white border-gray-200 hover:bg-gray-50"
                }`}
                aria-label={`Month ${m.i + 1}${m.appt ? " appointment set" : ""}`}
              >
                {new Date(2025, m.i, 1).toLocaleString(undefined, { month: "short" })}
                {m.appt && <span className="ml-2">🦷</span>}
              </button>
            ))}
          </div>
          <div className="mt-4 flex items-center">
            <Button onClick={validate}>Submit Plan</Button>
            {msg && <span className="ml-3 text-sm">{msg}</span>}
          </div>
        </Card>
      );
    }

    const FactBanner = ({ text }) => (
      <div className="bg-amber-50 border border-amber-200 text-amber-900 p-3 rounded-xl text-sm">{text}</div>
    );

    /* -------------- App Shell -------------- */
    function CariesPreventionGame() {
      const [level, setLevel] = useState(0);
      const [score, setScore] = useState(0);
      const [showHowTo, setShowHowTo] = useState(true);
      const next = () => setLevel(l => l + 1);

      return (
        <div className="min-h-screen w-full bg-gradient-to-b from-sky-50 to-white flex flex-col items-center px-4 py-8">
          <div className="w-full max-w-4xl flex items-center justify-between mb-6">
            <h1 className="text-2xl sm:text-3xl font-bold tracking-tight">Caries Prevention Quest</h1>
            <div className="text-sm text-gray-600">Score: <span className="font-semibold">{score}</span></div>
          </div>

          {showHowTo && (
            <Card title="How to Play">
              <ul className="list-disc ml-6 text-sm text-gray-700 space-y-1">
                <li><b>Level 1 – Candy Crack:</b> Drop candy to make cracks, then brush side‑to‑side to clean back to 0.</li>
                <li><b>Level 2 – Brush Boss:</b> 20 primary teeth (2×10). Clean the 10 yellow ones.</li>
                <li><b>Level 3 – Floss Frenzy:</b> Anterior only (6 upper + 6 lower). Clear all contacts.</li>
                <li><b>Level 4 – Sealant Splash:</b> Draw a cross or reach ≥20% coverage.</li>
                <li><b>Level 5 – Checkup Challenge:</b> High‑risk recall every 3 months.</li>
              </ul>
              <div className="mt-4"><Button onClick={() => setShowHowTo(false)} variant="success">Start</Button></div>
            </Card>
          )}

          {!showHowTo && level === 0 && (
            <CandyCrack onComplete={() => { setScore(s => s + 80); next(); }} />
          )}

          {level === 1 && (
            <BrushBoss
              onComplete={() => { setScore(s => s + 100); next(); }}
              onFail={() => { setScore(s => Math.max(0, s - 20)); next(); }}
            />
          )}

          {level === 2 && (
            <div className="w-full flex flex-col items-center gap-4">
              <FactBanner text="Floss once a day. Curve around each tooth in a “C” shape and move up & down." />
              <FlossFrenzy
                onComplete={() => { setScore(s => s + 100); next(); }}
                onFail={() => { setScore(s => Math.max(0, s - 20)); next(); }}
              />
            </div>
          )}

          {level === 3 && (
            <div className="w-full flex flex-col items-center gap-4">
              <FactBanner text="Sealants protect deep grooves of molars and reduce cavities." />
              <SealantSplash
                onComplete={() => { setScore(s => s + 120); next(); }}
                onFail={() => { setScore(s => Math.max(0, s - 20)); next(); }}
              />
            </div>
          )}

          {level === 4 && (
            <div className="w-full flex flex-col items-center gap-4">
              <FactBanner text="High‑risk children often need recall every 3 months for fluoride, sealants, and early detection." />
              <CheckupChallenge
                onComplete={() => { setScore(s => s + 80); next(); }}
                onFail={() => { setScore(s => Math.max(0, s - 20)); }}
              />
            </div>
          )}

          {level >= 5 && (
            <Card title="You Did It!">
              <p className="text-gray-700">
                You mastered <b>candy risk</b>, <b>brushing</b>, <b>flossing</b>, <b>sealants</b>, and <b>regular checkups</b>.
              </p>
              <ul className="list-disc ml-6 mt-3 text-gray-700 text-sm">
                <li>Limit sugary snacks; rinse or brush after treats.</li>
                <li>Brush 2×/day for 2 minutes with fluoride toothpaste.</li>
                <li>Floss once a day to clean where brushes can’t reach.</li>
                <li>Ask about sealants for new molars.</li>
                <li>High‑risk recall: every 3 months.</li>
              </ul>
              <div className="mt-4 flex items-center">
                <Button onClick={() => { window.location.reload(); }}>Play Again</Button>
                <Button variant="ghost" onClick={() => window.print()}>Print Tips</Button>
              </div>
            </Card>
          )}

          <footer className="mt-8 text-xs text-gray-500">WesternU Dental Medicine.</footer>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<CariesPreventionGame />);
  </script>
</body>
</html>
